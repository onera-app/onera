/**
 * Azure IMDS Attestation Verification
 *
 * Verifies PKCS7-signed attestation documents from Azure Instance Metadata Service.
 * The attestation proves the code is running on an Azure Confidential VM.
 */

import * as pkijs from 'pkijs';
import * as asn1js from 'asn1js';

// Microsoft Azure Attestation root certificate (DigiCert Global Root G2)
// This is the trust anchor for Azure attestation documents
// Certificate valid until: 2038-01-15
// SHA256 Fingerprint: CB:3C:CB:B7:60:31:E5:E0:13:8F:8D:D3:9A:23:F9:DE:47:FF:C3:5E:43:C1:14:4C:EA:27:D4:6A:5A:B1:CB:5F
const MICROSOFT_ROOT_CERT_DER = new Uint8Array([
  0x30, 0x82, 0x03, 0x8e, 0x30, 0x82, 0x02, 0x76, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x03,
  0x3a, 0xf1, 0xe6, 0xa7, 0x11, 0xa9, 0xa0, 0xbb, 0x28, 0x64, 0xb1, 0x1d, 0x09, 0xfa, 0xe5, 0x30,
  0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x61,
  0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30,
  0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
  0x20, 0x49, 0x6e, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x10, 0x77,
  0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x31,
  0x20, 0x30, 0x1e, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x17, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65,
  0x72, 0x74, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x47,
  0x32, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x33, 0x30, 0x38, 0x30, 0x31, 0x31, 0x32, 0x30, 0x30, 0x30,
  0x30, 0x5a, 0x17, 0x0d, 0x33, 0x38, 0x30, 0x31, 0x31, 0x35, 0x31, 0x32, 0x30, 0x30, 0x30, 0x30,
  0x5a, 0x30, 0x61, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
  0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c, 0x44, 0x69, 0x67, 0x69, 0x43,
  0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0b,
  0x13, 0x10, 0x77, 0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63,
  0x6f, 0x6d, 0x31, 0x20, 0x30, 0x1e, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x17, 0x44, 0x69, 0x67,
  0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x20, 0x52, 0x6f, 0x6f,
  0x74, 0x20, 0x47, 0x32, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
  0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a,
  0x02, 0x82, 0x01, 0x01, 0x00, 0xbb, 0x37, 0xcd, 0x34, 0xdc, 0x7b, 0x6b, 0xc9, 0xb2, 0x68, 0x90,
  0xad, 0x4a, 0x75, 0xff, 0x46, 0xba, 0x21, 0x0a, 0x08, 0x8d, 0xf5, 0x19, 0x54, 0xc9, 0xfb, 0x88,
  0xdb, 0xf3, 0xae, 0xf2, 0x3a, 0x89, 0x91, 0x3c, 0x7a, 0xe6, 0xab, 0x06, 0x1a, 0x6b, 0xcf, 0xac,
  0x2d, 0xe8, 0x5e, 0x09, 0x24, 0x44, 0xba, 0x62, 0x9a, 0x7e, 0xd6, 0xa3, 0xa8, 0x7e, 0xe0, 0x54,
  0x75, 0x20, 0x05, 0xac, 0x50, 0xb7, 0x9c, 0x63, 0x1a, 0x6c, 0x30, 0xdc, 0xda, 0x1f, 0x19, 0xb1,
  0xd7, 0x1e, 0xde, 0xfd, 0xd7, 0xe0, 0xcb, 0x94, 0x83, 0x37, 0xae, 0xec, 0x1f, 0x43, 0x4e, 0xdd,
  0x7b, 0x2c, 0xd2, 0xbd, 0x2e, 0xa5, 0x2f, 0xe4, 0xa9, 0xb8, 0xad, 0x3a, 0xd4, 0x99, 0xa4, 0xb6,
  0x25, 0xe9, 0x9b, 0x6b, 0x00, 0x60, 0x92, 0x60, 0xff, 0x4f, 0x21, 0x49, 0x18, 0xf7, 0x67, 0x90,
  0xab, 0x61, 0x06, 0x9c, 0x8f, 0xf2, 0xba, 0xe9, 0xb4, 0xe9, 0x92, 0x32, 0x6b, 0xb5, 0xf3, 0x57,
  0xe8, 0x5d, 0x1b, 0xcd, 0x8c, 0x1d, 0xab, 0x95, 0x04, 0x95, 0x49, 0xf3, 0x35, 0x2d, 0x96, 0xe3,
  0x49, 0x6d, 0xdd, 0x77, 0xe3, 0xfb, 0x49, 0x4b, 0xb4, 0xac, 0x55, 0x07, 0xa9, 0x8f, 0x95, 0xb3,
  0xb4, 0x23, 0xbb, 0x4c, 0x6d, 0x45, 0xf0, 0xf6, 0xa9, 0xb2, 0x95, 0x30, 0xb4, 0xfd, 0x4c, 0x55,
  0x8c, 0x27, 0x4a, 0x57, 0x14, 0x7c, 0x82, 0x9d, 0xcd, 0x73, 0x92, 0xd3, 0x16, 0x4a, 0x06, 0x0c,
  0x8c, 0x50, 0xd1, 0x8f, 0x1e, 0x09, 0xbe, 0x17, 0xa1, 0xe6, 0x21, 0xca, 0xfd, 0x83, 0xe5, 0x10,
  0xbc, 0x83, 0xa5, 0x0a, 0xc4, 0x67, 0x28, 0xf6, 0x73, 0x14, 0x14, 0x3d, 0x46, 0x76, 0xc3, 0x87,
  0x14, 0x89, 0x21, 0x34, 0x4d, 0xaf, 0x0f, 0x45, 0x0c, 0xa6, 0x49, 0xa1, 0xba, 0xbb, 0x9c, 0xc5,
  0xb1, 0x33, 0x83, 0x29, 0x85, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x42, 0x30, 0x40, 0x30, 0x0f,
  0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,
  0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30,
  0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x4e, 0x22, 0x54, 0x20, 0x18, 0x95,
  0xe6, 0xe3, 0x6e, 0xe6, 0x0f, 0xfa, 0xfa, 0xb9, 0x12, 0xed, 0x06, 0x17, 0x8f, 0x39, 0x30, 0x0d,
  0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01,
  0x01, 0x00, 0x60, 0x67, 0x28, 0x94, 0x6f, 0x0e, 0x48, 0x63, 0xeb, 0x31, 0xdd, 0xea, 0x67, 0x18,
  0xd5, 0x89, 0x7d, 0x3c, 0xc0, 0x9c, 0x8a, 0xde, 0x84, 0xee, 0xa1, 0xef, 0xbc, 0xa3, 0x16, 0xb6,
  0x8a, 0x9d, 0x39, 0xbc, 0xde, 0xc8, 0xc8, 0x55, 0x40, 0x60, 0x67, 0xd5, 0x41, 0x07, 0xa0, 0xdd,
  0x2b, 0x2b, 0xd2, 0xb6, 0xe7, 0x2b, 0x7b, 0xad, 0x0d, 0x12, 0x1c, 0x5a, 0xd6, 0x4d, 0x13, 0x05,
  0x35, 0x12, 0x09, 0x8c, 0xa9, 0x85, 0x18, 0x27, 0xcf, 0xf0, 0xe3, 0x96, 0x67, 0x45, 0x59, 0xbc,
  0x09, 0xf4, 0xbe, 0x3c, 0x7a, 0x39, 0x39, 0x78, 0x17, 0xe0, 0xa3, 0xd5, 0xde, 0xe8, 0x2d, 0x94,
  0x38, 0x4b, 0xf7, 0x77, 0x55, 0xbe, 0x23, 0xf1, 0x47, 0xb9, 0x75, 0xf6, 0x73, 0x43, 0x73, 0xcf,
  0x7f, 0x78, 0x60, 0x44, 0xa8, 0x10, 0xa3, 0xed, 0xe5, 0x2f, 0xf1, 0x59, 0x32, 0x13, 0xf6, 0xbf,
  0xb9, 0x58, 0x0d, 0xf3, 0x53, 0x98, 0x59, 0x8d, 0xc3, 0x3c, 0x0c, 0x17, 0xce, 0x5c, 0x55, 0xa4,
  0xfc, 0x36, 0x15, 0x66, 0x41, 0xb7, 0x0c, 0x6c, 0x31, 0xdf, 0x35, 0x2a, 0x26, 0x08, 0x06, 0x10,
  0xbd, 0x90, 0x0c, 0x6d, 0x0a, 0xf9, 0x95, 0x0a, 0x73, 0x32, 0xa6, 0x3a, 0x1b, 0x83, 0x98, 0x3e,
  0xcb, 0x09, 0x27, 0x4c, 0x42, 0x07, 0xf9, 0x15, 0xe1, 0x00, 0x9b, 0x41, 0x3d, 0x95, 0x29, 0x60,
  0xe1, 0x62, 0x63, 0x6f, 0x36, 0x64, 0xf3, 0xd0, 0x0a, 0xee, 0x93, 0x81, 0xb6, 0x2b, 0x84, 0x1c,
  0xa7, 0x5c, 0x93, 0x93, 0xc0, 0x5b, 0x19, 0x9a, 0x93, 0xf8, 0x6f, 0x7c, 0x04, 0x78, 0x48, 0x1d,
  0xb2, 0x46, 0x44, 0x41, 0xe3, 0xdf, 0x59, 0xe5, 0xc8, 0xbf, 0x02, 0xd0, 0x80, 0x5e, 0xff, 0xd7,
  0xcc, 0x34, 0x95, 0xc7, 0x38, 0x0e, 0x4c, 0x4f, 0xe9, 0xf1, 0x1b, 0x42, 0xc7, 0xd2, 0x91, 0x57,
  0x6d, 0xf1
]);

/**
 * Decode base64 to Uint8Array.
 * Uses a simple, reliable implementation that works in all environments.
 */
function base64ToBytes(base64: string): Uint8Array {
  // Remove whitespace and normalize
  let str = base64.replace(/\s/g, '');

  // Add padding if needed
  while (str.length % 4 !== 0) {
    str += '=';
  }

  // Use built-in decoding where available
  if (typeof globalThis.Buffer !== 'undefined') {
    // Node.js
    return new Uint8Array(globalThis.Buffer.from(str, 'base64'));
  }

  // Browser - use atob with proper binary conversion
  const binaryStr = atob(str);
  const bytes = new Uint8Array(binaryStr.length);
  for (let i = 0; i < binaryStr.length; i++) {
    bytes[i] = binaryStr.charCodeAt(i);
  }
  return bytes;
}

/**
 * Parse DER-encoded certificate to pkijs Certificate
 */
function parseDerCertificate(der: Uint8Array): pkijs.Certificate {
  console.log('[Cert] Parsing certificate, DER length:', der.length);
  // Create a new ArrayBuffer with an exact copy of the data
  const buffer = new ArrayBuffer(der.length);
  new Uint8Array(buffer).set(der);
  const asn1 = asn1js.fromBER(buffer);
  if (asn1.offset === -1) {
    console.error('[Cert] ASN.1 parse failed');
    throw new Error('Failed to parse certificate ASN.1');
  }
  console.log('[Cert] ASN.1 parse succeeded');
  return new pkijs.Certificate({ schema: asn1.result });
}

/**
 * Result of Azure IMDS attestation verification
 */
export interface AzureImdsVerificationResult {
  valid: boolean;
  error?: string;
  signedContent?: Uint8Array;
  signerCertificate?: pkijs.Certificate;
}

/**
 * Decode base64 with support for various formats Azure IMDS may return.
 * Azure IMDS may return standard base64, URL-safe base64, or base64 with line breaks.
 * Uses native browser/Node.js base64 decoding which is more lenient than libsodium.
 */
function decodeAzureBase64(input: string): Uint8Array {
  // Log first 100 chars for debugging
  console.log('[Azure IMDS] Base64 input preview:', input.substring(0, 100));
  console.log('[Azure IMDS] Base64 input length:', input.length);

  // Remove any whitespace/line breaks that Azure may include
  let cleaned = input.replace(/\s/g, '');

  // Convert URL-safe base64 to standard base64 if needed
  cleaned = cleaned.replace(/-/g, '+').replace(/_/g, '/');

  // Remove any characters that aren't valid base64
  // Valid base64 chars: A-Z, a-z, 0-9, +, /, =
  const invalidChars = cleaned.match(/[^A-Za-z0-9+/=]/g);
  if (invalidChars) {
    console.warn('[Azure IMDS] Found invalid base64 characters:', [...new Set(invalidChars)].join(''));
    cleaned = cleaned.replace(/[^A-Za-z0-9+/=]/g, '');
  }

  // Add padding if missing
  while (cleaned.length % 4 !== 0) {
    cleaned += '=';
  }

  console.log('[Azure IMDS] Cleaned base64 length:', cleaned.length);

  try {
    return base64ToBytes(cleaned);
  } catch (e) {
    // Log more details on failure
    console.error('[Azure IMDS] Base64 decode failed. First 200 chars of cleaned input:', cleaned.substring(0, 200));
    throw e;
  }
}

/**
 * Verify Azure IMDS PKCS7 attestation signature.
 *
 * @param rawQuoteBase64 - Base64-encoded PKCS7 signed data from Azure IMDS
 * @returns Verification result with signed content if valid
 */
export async function verifyAzureImdsPkcs7Signature(
  rawQuoteBase64: string
): Promise<AzureImdsVerificationResult> {
  try {
    // Set up crypto engine for pkijs
    const crypto = typeof window !== 'undefined' ? window.crypto : globalThis.crypto;
    const cryptoEngine = new pkijs.CryptoEngine({
      name: 'WebCrypto',
      crypto: crypto as Crypto,
    });
    pkijs.setEngine('WebCrypto', crypto as Crypto, cryptoEngine);

    // Parse the PKCS7 signed data (handle various Azure base64 formats)
    let pkcs7Der: Uint8Array;
    try {
      pkcs7Der = decodeAzureBase64(rawQuoteBase64);
      console.log('[PKCS7] Decoded PKCS7 length:', pkcs7Der.length, 'first bytes:', Array.from(pkcs7Der.slice(0, 10)));
    } catch (e) {
      return { valid: false, error: `Failed to decode base64: ${e instanceof Error ? e.message : 'unknown error'}` };
    }
    const asn1 = asn1js.fromBER(pkcs7Der.buffer.slice(pkcs7Der.byteOffset, pkcs7Der.byteOffset + pkcs7Der.byteLength) as ArrayBuffer);
    if (asn1.offset === -1) {
      return { valid: false, error: 'Failed to parse PKCS7 ASN.1 structure' };
    }

    // Parse as ContentInfo (PKCS7 wrapper)
    const contentInfo = new pkijs.ContentInfo({ schema: asn1.result });

    // Verify it's signed data
    if (contentInfo.contentType !== '1.2.840.113549.1.7.2') {
      return { valid: false, error: 'PKCS7 content is not SignedData' };
    }

    // Parse the SignedData
    const signedData = new pkijs.SignedData({ schema: contentInfo.content });

    // Get the embedded certificates
    if (!signedData.certificates || signedData.certificates.length === 0) {
      return { valid: false, error: 'No certificates found in PKCS7' };
    }

    // Parse the trusted root certificate
    const trustedRoot = parseDerCertificate(MICROSOFT_ROOT_CERT_DER);

    // Build certificate chain and find signer
    const certificates = signedData.certificates.filter(
      (cert): cert is pkijs.Certificate => cert instanceof pkijs.Certificate
    );

    // Debug: Log certificate info
    console.log('[PKCS7] Number of certificates in PKCS7:', certificates.length);
    for (let i = 0; i < certificates.length; i++) {
      const cert = certificates[i];
      const subject = cert.subject.typesAndValues.map(tv => {
        const type = tv.type;
        const value = tv.value.valueBlock.value;
        return `${type}=${value}`;
      }).join(', ');
      const issuer = cert.issuer.typesAndValues.map(tv => {
        const type = tv.type;
        const value = tv.value.valueBlock.value;
        return `${type}=${value}`;
      }).join(', ');
      console.log(`[PKCS7] Cert ${i}: Subject: ${subject}`);
      console.log(`[PKCS7] Cert ${i}: Issuer: ${issuer}`);
    }

    // Also log the trusted root info
    const rootSubject = trustedRoot.subject.typesAndValues.map(tv => {
      const type = tv.type;
      const value = tv.value.valueBlock.value;
      return `${type}=${value}`;
    }).join(', ');
    console.log('[PKCS7] Trusted root subject:', rootSubject);

    // Manually verify the signature since pkijs has issues with algorithm resolution
    const signerInfo = signedData.signerInfos[0];
    if (!signerInfo) {
      return { valid: false, error: 'No signer info in PKCS7' };
    }

    // Get the signer certificate
    const signerCert = certificates[0];
    if (!signerCert) {
      return { valid: false, error: 'No signer certificate found' };
    }

    // Log signature algorithm for debugging
    const sigAlgOid = signerInfo.signatureAlgorithm.algorithmId;
    console.log('[PKCS7] Signature algorithm OID:', sigAlgOid);

    // Get hash algorithm - it may be in signature algorithm or digest algorithm
    // 1.2.840.113549.1.1.1 = rsaEncryption (hash in digestAlgorithm)
    // 1.2.840.113549.1.1.11 = sha256WithRSAEncryption
    // 1.2.840.113549.1.1.12 = sha384WithRSAEncryption
    // 1.2.840.113549.1.1.13 = sha512WithRSAEncryption
    // 1.2.840.113549.1.1.5 = sha1WithRSAEncryption
    let hashAlgorithm: string;

    if (sigAlgOid === '1.2.840.113549.1.1.11') {
      hashAlgorithm = 'SHA-256';
    } else if (sigAlgOid === '1.2.840.113549.1.1.12') {
      hashAlgorithm = 'SHA-384';
    } else if (sigAlgOid === '1.2.840.113549.1.1.13') {
      hashAlgorithm = 'SHA-512';
    } else if (sigAlgOid === '1.2.840.113549.1.1.5') {
      hashAlgorithm = 'SHA-1';
    } else if (sigAlgOid === '1.2.840.113549.1.1.1') {
      // rsaEncryption - get hash from digestAlgorithm
      const digestAlgOid = signerInfo.digestAlgorithm.algorithmId;
      console.log('[PKCS7] Digest algorithm OID:', digestAlgOid);
      // 2.16.840.1.101.3.4.2.1 = SHA-256
      // 2.16.840.1.101.3.4.2.2 = SHA-384
      // 2.16.840.1.101.3.4.2.3 = SHA-512
      // 1.3.14.3.2.26 = SHA-1
      if (digestAlgOid === '2.16.840.1.101.3.4.2.1') {
        hashAlgorithm = 'SHA-256';
      } else if (digestAlgOid === '2.16.840.1.101.3.4.2.2') {
        hashAlgorithm = 'SHA-384';
      } else if (digestAlgOid === '2.16.840.1.101.3.4.2.3') {
        hashAlgorithm = 'SHA-512';
      } else if (digestAlgOid === '1.3.14.3.2.26') {
        hashAlgorithm = 'SHA-1';
      } else {
        return { valid: false, error: `Unsupported digest algorithm: ${digestAlgOid}` };
      }
    } else {
      return { valid: false, error: `Unsupported signature algorithm: ${sigAlgOid}` };
    }

    console.log('[PKCS7] Hash algorithm:', hashAlgorithm);

    // Import the public key from the certificate
    const publicKeyInfo = signerCert.subjectPublicKeyInfo;
    const publicKeyDer = publicKeyInfo.toSchema().toBER(false);

    const cryptoKey = await crypto.subtle.importKey(
      'spki',
      publicKeyDer,
      { name: 'RSASSA-PKCS1-v1_5', hash: { name: hashAlgorithm } },
      false,
      ['verify']
    );

    // Get the data that was signed (SignedAttributes or content)
    let dataToVerify: ArrayBuffer;
    if (signerInfo.signedAttrs) {
      // When SignedAttrs are present, they are what's signed (with EXPLICIT tag changed to SET)
      const signedAttrsSchema = signerInfo.signedAttrs.toSchema();
      // Change the tag from EXPLICIT [0] to SET
      signedAttrsSchema.idBlock.tagClass = 1; // UNIVERSAL
      signedAttrsSchema.idBlock.tagNumber = 17; // SET
      dataToVerify = signedAttrsSchema.toBER(false);
    } else if (signedData.encapContentInfo?.eContent) {
      // If no SignedAttrs, the content itself is signed
      const content = signedData.encapContentInfo.eContent;
      if (content instanceof asn1js.OctetString) {
        dataToVerify = content.valueBlock.valueHexView.slice().buffer;
      } else {
        return { valid: false, error: 'Unexpected content type' };
      }
    } else {
      return { valid: false, error: 'No data to verify' };
    }

    // Get the signature (copy to new ArrayBuffer to satisfy TypeScript)
    const signatureView = signerInfo.signature.valueBlock.valueHexView;
    const signatureBuffer = new ArrayBuffer(signatureView.length);
    new Uint8Array(signatureBuffer).set(signatureView);

    // Verify the signature
    const verificationResult = await crypto.subtle.verify(
      { name: 'RSASSA-PKCS1-v1_5' },
      cryptoKey,
      signatureBuffer,
      dataToVerify
    );

    if (!verificationResult) {
      return { valid: false, error: 'PKCS7 signature verification failed' };
    }

    console.log('[PKCS7] Signature verification succeeded');

    // Extract the signed content
    let signedContent: Uint8Array | undefined;
    if (signedData.encapContentInfo?.eContent) {
      const contentAsn1 = signedData.encapContentInfo.eContent;
      if (contentAsn1 instanceof asn1js.OctetString) {
        signedContent = new Uint8Array(contentAsn1.valueBlock.valueHexView);
      }
    }

    return {
      valid: true,
      signedContent,
      signerCertificate: certificates[0],
    };
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : 'PKCS7 verification error',
    };
  }
}

/**
 * Extract attestation claims from verified PKCS7 content.
 * The content is JSON with the attestation report.
 */
export function parseAzureAttestationClaims(signedContent: Uint8Array): Record<string, unknown> | null {
  try {
    const decoder = new TextDecoder();
    const json = decoder.decode(signedContent);
    return JSON.parse(json);
  } catch {
    return null;
  }
}
